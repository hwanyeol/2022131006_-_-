1
class Solution:
    def setdata(self,first,second):
        n=len(first)
        for i in range(n):
            for j in range(i+1,n+1):
                if first[i]+first[j]==second:
                    return print([i,j])
        
a=Solution()
a.setdata([2,7,11,15],9)
2
class Solution:
    def addTwoNumbers(self, l1, l2):
        self.l1=l1
        self.l2=l2
        a=0
        b=[]
        for i in range(len(l1)):
            a=l1[i]*10^i+a
        for i in range(len(l2)):
            a=a+l2[i]*10^i
        for i in range(len(str(a))):
            b.append(a%10)
            a=a//10
        return b
c=Solution()
print(c.addTwoNumbers([2,4,3],[5,6,4]))
9
13
14
20
21
26
27
28
55
67
69
83
88
100
101
118
121
125
160
168
169
171
191
202
203
217
228
231
257
263
268
283
290
292
326
342
344
345
349
350
367
383
389
392
401
405
409
412
415
434
441
448
455
459
461
463
482
485
492
495
496
500
501
504
506
507
509
520
521
530
541
543
551
557
561
563
566
572
575
594
598
599
617
628
637
643
645
653
657
661
671
674
680
682
693
696
697
700
704
709
717
724
728
733
744
746
747
748
762
766
771
783
796
804
806
812
819
821
824
830
832
836
844
859
860
867
868
872
876
883
884
888
896
897
905
908
class Solution:
    def smallestRangeI(self, nums: List[int], k: int) -> int:
        min_num = min(nums)
        max_num = max(nums)
        
        min_possible_range = max_num - k - (min_num + k)
        
        return max(0, min_possible_range)

914
from collections import Counter
from math import gcd
from functools import reduce

class Solution:
    def hasGroupsSizeX(self, deck: List[int]) -> bool:
        count = Counter(deck)
        values = list(count.values())
        
        def find_gcd(a, b):
            return gcd(a, b)
        
        gcd_value = reduce(find_gcd, values)
        
        return gcd_value > 1

917
class Solution:
    def reverseOnlyLetters(self, s: str) -> str:
        s_list = list(s)
        left, right = 0, len(s) - 1
        
        while left < right:
            if s_list[left].isalpha() and s_list[right].isalpha():
                # Swap characters
                s_list[left], s_list[right] = s_list[right], s_list[left]
                left += 1
                right -= 1
            elif not s_list[left].isalpha():
                left += 1
            elif not s_list[right].isalpha():
                right -= 1
        
        return ''.join(s_list)

922
class Solution:
    def sortArrayByParityII(self, nums: List[int]) -> List[int]:
        n = len(nums)
        even_index, odd_index = 0, 1
        
        while even_index < n and odd_index < n:
            if nums[even_index] % 2 == 0:
                even_index += 2
            elif nums[odd_index] % 2 == 1:
                odd_index += 2
            else:
                # Swap nums[even_index] and nums[odd_index]
                nums[even_index], nums[odd_index] = nums[odd_index], nums[even_index]
                even_index += 2
                odd_index += 2
        
        return nums

925
class Solution:
    def isLongPressedName(self, name: str, typed: str) -> bool:
        i, j = 0, 0
        n, m = len(name), len(typed)
        
        while j < m:
            if i < n and name[i] == typed[j]:
                i += 1
                j += 1
            elif j > 0 and typed[j] == typed[j-1]:
                j += 1
            else:
                return False
        
        return i == n

929
class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        unique_emails = set()
        
        for email in emails:
            local_name, domain_name = email.split('@')
            
            # Normalize local name
            local_name = local_name.split('+')[0]  # Ignore everything after '+'
            local_name = local_name.replace('.', '')  # Remove all '.'
            
            # Construct normalized email
            normalized_email = local_name + '@' + domain_name
            
            # Add to set to ensure uniqueness
            unique_emails.add(normalized_email)
        
        return len(unique_emails)

938
class Solution:
    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:
        def dfs(node, low, high):
            if not node:
                return 0
            
            if node.val < low:
                return dfs(node.right, low, high)
            elif node.val > high:
                return dfs(node.left, low, high)
            else:
                return node.val + dfs(node.left, low, high) + dfs(node.right, low, high)
        
        return dfs(root, low, high)

941
class Solution:
    def validMountainArray(self, arr: List[int]) -> bool:
        n = len(arr)
        
        if n < 3:
            return False
        
        peak_index = arr.index(max(arr))
        
        if peak_index == 0 or peak_index == n - 1:
            return False
        
942
class Solution:
    def diStringMatch(self, s: str) -> List[int]:
        n = len(s)
        low, high = 0, n
        result = []
        
        for char in s:
            if char == 'I':
                result.append(low)
                low += 1
            elif char == 'D':
                result.append(high)
                high -= 1
        
        # Append the last remaining number
        result.append(low)
        
        return result

944
953
class Solution:
    def isAlienSorted(self, words: List[str], order: str) -> bool:
        order_map = {char: idx for idx, char in enumerate(order)}
        
        def is_sorted(w1, w2):
            for c1, c2 in zip(w1, w2):
                if order_map[c1] > order_map[c2]:
                    return False
                elif order_map[c1] < order_map[c2]:
                    break
            else:
                return len(w1) <= len(w2)
            return True
        
        for i in range(len(words) - 1):
            if not is_sorted(words[i], words[i + 1]):
                return False
        
        return True

961
class Solution:
    def repeatedNTimes(self, nums: List[int]) -> int:
        N = len(nums) // 2
        freq_map = {}
        
        for num in nums:
            if num in freq_map:
                freq_map[num] += 1
                if freq_map[num] == N:
                    return num
            else:
                freq_map[num] = 1

965
class Solution:
    def isUnivalTree(self, root: Optional[TreeNode]) -> bool:
        def is_unival(node, value):
            if not node:
                return True
            if node.val != value:
                return False
            return is_unival(node.left, value) and is_unival(node.right, value)
        
        if not root:
            return True
        return is_unival(root, root.val)

976
class Solution:
    def largestPerimeter(self, nums: List[int]) -> int:
        nums.sort(reverse=True)
        
        for i in range(len(nums) - 2):
            if nums[i] < nums[i + 1] + nums[i + 2]:
                return nums[i] + nums[i + 1] + nums[i + 2]
        
        return 0

977
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        n = len(nums)
        result = [0] * n
        left, right = 0, n - 1
        idx = n - 1
        
        while left <= right:
            left_square = nums[left] ** 2
            right_square = nums[right] ** 2
            
            if left_square > right_square:
                result[idx] = left_square
                left += 1
            else:
                result[idx] = right_square
                right -= 1
            idx -= 1
        
        return result

989
class Solution:
    def addToArrayForm(self, num: List[int], k: int) -> List[int]:
        result = []
        carry = 0
        
        while num or k > 0:
            if num:
                digit = num.pop()
            else:
                digit = 0
            
            total = digit + (k % 10) + carry
            carry = total // 10
            result.append(total % 10)
            
            k //= 10
        
        if carry:
            result.append(carry)
        
        return result[::-1]

993
class Solution:
    def isCousins(self, root: Optional[TreeNode], x: int, y: int) -> bool:
        x_parent, x_depth = None, -1
        y_parent, y_depth = None, -1
        
        def dfs(node, parent, depth):
            nonlocal x_parent, x_depth, y_parent, y_depth
            
            if not node:
                return
            
            if node.val == x:
                x_parent, x_depth = parent, depth
            elif node.val == y:
                y_parent, y_depth = parent, depth
            
            # Early return if both x and y are found
            if x_parent is not None and y_parent is not None:
                return
            
            dfs(node.left, node, depth + 1)
            dfs(node.right, node, depth + 1)
        
        dfs(root, None, 0)
        
        return x_depth == y_depth and x_parent != y_parent

997
class Solution:
    def findJudge(self, n: int, trust: List[List[int]]) -> int:
        trust_count = [0] * (n + 1)
        trusted_by_count = [0] * (n + 1)
        
        for a, b in trust:
            trust_count[a] -= 1
            trusted_by_count[b] += 1
        
        for i in range(1, n + 1):
            if trust_count[i] == 0 and trusted_by_count[i] == n - 1:
                return i
        
        return -1

999
class Solution:
    def numRookCaptures(self, board: List[List[str]]) -> int:
        n = len(board)
        rook_pos = None
        for i in range(n):
            for j in range(n):
                if board[i][j] == 'R':
                    rook_pos = (i, j)
                    break
            if rook_pos:
                break
        
        if not rook_pos:
            return 0
        
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        count = 0
        
        for d in directions:
            x, y = rook_pos
            dx, dy = d
            while 0 <= x + dx < n and 0 <= y + dy < n:
                x += dx
                y += dy
                if board[x][y] == 'B':
                    break
                if board[x][y] == 'p':
                    count += 1
                    break
        
        return count

1108
1619
from typing import List

class Solution:
    def trimMean(self, arr: List[int]) -> float:
        arr.sort()
        n = len(arr)
        remove_count = int(n * 0.05)
        trimmed_arr = arr[remove_count : n - remove_count]
        trimmed_mean = sum(trimmed_arr) / len(trimmed_arr)
        return trimmed_mean

1122
from typing import List
from collections import Counter

class Solution:
    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:
        counter = Counter(arr1)
        result = []
        
        for num in arr2:
            result.extend([num] * counter.pop(num, 0))
        
        rest = sorted(counter.elements())
        result.extend(rest)
        
        return result

1287
from typing import List

class Solution:
    def findSpecialInteger(self, arr: List[int]) -> int:
        threshold = len(arr) // 4
        count = 1

        for i in range(1, len(arr)):
            if arr[i] == arr[i - 1]:
                count += 1
                if count > threshold:
                    return arr[i]
            else:
                count = 1

        return arr[0]

1128
from typing import List
from collections import defaultdict

class Solution:
    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:
        count = defaultdict(int)
        pairs = 0

        for a, b in dominoes:
            key = tuple(sorted((a, b)))
            pairs += count[key]
            count[key] += 1

        return pairs

1137
class Solution:
    def tribonacci(self, n: int) -> int:
        if n == 0:
            return 0
        elif n == 1 or n == 2:
            return 1
        t0, t1, t2 = 0, 1, 1
        for i in range(3, n + 1):
            t3 = t0 + t1 + t2
            t0, t1, t2 = t1, t2, t3
        
        return t2
1331
from typing import List

class Solution:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        if not arr:
            return []
        
        sorted_arr = sorted(set(arr))
        rank_map = {num: rank + 1 for rank, num in enumerate(sorted_arr)}
        
        return [rank_map[num] for num in arr]

1154
class Solution:
    def dayOfYear(self, date: str) -> int:
        year, month, day = map(int, date.split('-'))
        
        days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        
        if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
            days_in_month[1] = 29
        
        return sum(days_in_month[:month - 1]) + day

1935
class Solution:
    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:
        broken_set = set(brokenLetters)
        words = text.split()
        count = 0
        
        for word in words:
            if not any(char in broken_set for char in word):
                count += 1
        
        return count

1360
from datetime import datetime

class Solution:
    def daysBetweenDates(self, date1: str, date2: str) -> int:
        # Parse input dates into datetime objects
        date_format = "%Y-%m-%d"
        d1 = datetime.strptime(date1, date_format).date()
        d2 = datetime.strptime(date2, date_format).date()
        
        # Calculate the difference in days
        delta = abs(d2 - d1).days
        
        return delta

1175
class Solution:
    def numPrimeArrangements(self, n: int) -> int:
        MOD = 10**9 + 7
        
        def is_prime(num):
            if num <= 1:
                return False
            if num <= 3:
                return True
            if num % 2 == 0 or num % 3 == 0:
                return False
            i = 5
            while i * i <= num:
                if num % i == 0 or num % (i + 2) == 0:
                    return False
                i += 6
            return True
        
        count_primes = sum(1 for i in range(1, n + 1) if is_prime(i))
        
        def factorial(num):
            if num <= 1:
                return 1
            result = 1
            for i in range(2, num + 1):
                result = (result * i) % MOD
            return result
        
        prime_factorial = factorial(count_primes)
        non_prime_factorial = factorial(n - count_primes)
        
        return (prime_factorial * non_prime_factorial) % MOD

1184
from typing import List

class Solution:
    def distanceBetweenBusStops(self, distance: List[int], start: int, destination: int) -> int:
        if start > destination:
            start, destination = destination, start
        
        clockwise_distance = sum(distance[start:destination])
        counterclockwise_distance = sum(distance[destination:] + distance[:start])
        
        return min(clockwise_distance, counterclockwise_distance)

1185
from datetime import datetime

class Solution:
    def dayOfTheWeek(self, day: int, month: int, year: int) -> str:
        # Create a datetime object for the given date
        date_object = datetime(year, month, day)
        
        # Get the day of the week as a string (Monday, Tuesday, etc.)
        day_of_week = date_object.strftime("%A")
        
        return day_of_week

1189
from collections import Counter

class Solution:
    def maxNumberOfBalloons(self, text: str) -> int:
        balloon_counts = {'b': 1, 'a': 1, 'l': 2, 'o': 2, 'n': 1}
        text_counts = Counter(text)
        max_balloons = float('inf')
        
        for char, count in balloon_counts.items():
            max_balloons = min(max_balloons, text_counts.get(char, 0) // count)
1200
from typing import List

class Solution:
    def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:
        arr.sort()
        min_abs_diff = float('inf')
        result = []
        
        for i in range(1, len(arr)):
            abs_diff = arr[i] - arr[i - 1]
            
            if abs_diff < min_abs_diff:
                min_abs_diff = abs_diff
                result = [[arr[i - 1], arr[i]]]
            elif abs_diff == min_abs_diff:
                result.append([arr[i - 1], arr[i]])
        
        return result

1207
from typing import List

class Solution:
    def uniqueOccurrences(self, arr: List[int]) -> bool:
        count_map = {}
        for num in arr:
            if num in count_map:
                count_map[num] += 1
            else:
                count_map[num] = 1
        
        occurrence_counts = count_map.values()
        return len(occurrence_counts) == len(set(occurrence_counts))

1217
from typing import List

class Solution:
    def minCostToMoveChips(self, position: List[int]) -> int:
        even_count = sum(1 for pos in position if pos % 2 == 0)
        odd_count = len(position) - even_count
        
        return min(even_count, odd_count)

1221
1287
1309
class Solution:
    def freqAlphabets(self, s: str) -> str:
        result = []
        i = 0
        while i < len(s):
            if i + 2 < len(s) and s[i + 2] == '#':
                # Decode two-digit number
                num = int(s[i:i + 2])
                result.append(chr(ord('a') + num - 1))
                i += 3
            else:
                # Decode single-digit number
                num = int(s[i])
                result.append(chr(ord('a') + num - 1))
                i += 1
        
        return ''.join(result)

1313
from typing import List

class Solution:
    def decompressRLElist(self, nums: List[int]) -> List[int]:
        result = []
        for i in range(0, len(nums), 2):
            freq = nums[i]
            value = nums[i + 1]
            result.extend([value] * freq)
        return result

1317
from typing import List

class Solution:
    def getNoZeroIntegers(self, n: int) -> List[int]:
        def contains_zero_digit(num):
            return '0' in str(num)
        
        for i in range(1, n):
            if not contains_zero_digit(i) and not contains_zero_digit(n - i):
                return [i, n - i]
        
        return []
1323
class Solution:
    def maximum69Number (self, num: int) -> int:
        num_str = str(num)
        for i in range(len(num_str)):
            if num_str[i] == '6':
                num_str = num_str[:i] + '9' + num_str[i+1:]
                break
        return int(num_str)

1331
1332
class Solution:
    def removePalindromeSub(self, s: str) -> int:
        if not s:
            return 0
        
        if s == s[::-1]:
            return 1
        
        return 2

1337
from typing import List

class Solution:
    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:
        # Calculate the strength (number of 1s) for each row
        row_strength = []
        for i in range(len(mat)):
            strength = sum(mat[i])
            row_strength.append((i, strength))
        
        # Sort rows by strength (number of 1s)
        row_strength.sort(key=lambda x: x[1])
        
        # Extract indices of the k weakest rows
        result = [row_strength[i][0] for i in range(k)]
        
        return result

1342
class Solution:
    def numberOfSteps(self, num: int) -> int:
        steps = 0
        while num > 0:
            if num % 2 == 0:
                num //= 2
            else:
                num -= 1
            steps += 1
        return steps

1346
from typing import List

class Solution:
    def checkIfExist(self, arr: List[int]) -> bool:
        seen = set()
        for num in arr:
            if 2 * num in seen or (num % 2 == 0 and num // 2 in seen):
                return True
            seen.add(num)
        return False

1356
from typing import List

class Solution:
    def sortByBits(self, arr: List[int]) -> List[int]:
        def count_ones(num):
            return bin(num).count('1')
        
        # Sort by number of 1's in binary representation, then by the number itself
        return sorted(arr, key=lambda x: (count_ones(x), x))

1360
1365
from typing import List

class Solution:
    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:
        # Create a copy of nums and sort it
        sorted_nums = sorted(nums)
        
        # Create a dictionary to store the count of smaller numbers for each unique number
        count_smaller = {}
        for i, num in enumerate(sorted_nums):
            if num not in count_smaller:
                count_smaller[num] = i
        
        # Generate the result array based on the dictionary
        result = []
        for num in nums:
            result.append(count_smaller[num])
        
        return result

1374
class Solution:
    def generateTheString(self, n: int) -> str:
        if n % 2 == 1:
            return 'a' * n
        else:
            return 'a' * (n - 1) + 'b'

1379
class Solution:
    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:
        def dfs(node_original, node_cloned):
            if node_original is None:
                return None
            if node_original == target:
                return node_cloned
            left_result = dfs(node_original.left, node_cloned.left)
            if left_result:
                return left_result
            return dfs(node_original.right, node_cloned.right)
        
        return dfs(original, cloned)

1380
from typing import List

class Solution:
    def luckyNumbers (self, matrix: List[List[int]]) -> List[int]:
        # Initialize lists to store minimums of rows and maximums of columns
        min_rows = [min(row) for row in matrix]
        max_cols = [max(matrix[i][j] for i in range(len(matrix))) for j in range(len(matrix[0]))]
        
        # Find the intersection of minimum rows and maximum columns
        lucky_numbers = [matrix[i][j] for i in range(len(matrix)) for j in range(len(matrix[0])) 
                         if matrix[i][j] == min_rows[i] and matrix[i][j] == max_cols[j]]
        
        return lucky_numbers

1385
from typing import List

class Solution:
    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:
        count = 0
        for x in arr1:
            valid = True
            for y in arr2:
                if abs(x - y) <= d:
                    valid = False
                    break
            if valid:
                count += 1
        return count

1389
class Solution:
    def createTargetArray(self, nums: List[int], index: List[int]) -> List[int]:
        target = []
        for num, idx in zip(nums, index):
            target.insert(idx, num)
        return target

1394
from typing import List

class Solution:
    def findLucky(self, arr: List[int]) -> int:
        frequency = {}
        
        # Count frequencies of each number in arr
        for num in arr:
            if num in frequency:
                frequency[num] += 1
            else:
                frequency[num] = 1
        
        # Initialize the maximum lucky number found
        max_lucky = -1
        
        # Find the maximum number where number equals its frequency
        for num, count in frequency.items():
            if num == count:
                max_lucky = max(max_lucky, num)
        
        return max_lucky
1399
class Solution:
    def countLargestGroup(self, n: int) -> int:
        # Helper function to calculate digit sum
        def digit_sum(num):
            return sum(int(digit) for digit in str(num))
        
        # Dictionary to store sum of digits -> count of numbers
        digit_sum_count = {}
        
        # Iterate over each number from 1 to n
        for num in range(1, n + 1):
            sum_digits = digit_sum(num)
            if sum_digits in digit_sum_count:
                digit_sum_count[sum_digits] += 1
            else:
                digit_sum_count[sum_digits] = 1
        
        # Find the largest sum of digits
        max_sum = max(digit_sum_count.values())
        
        # Count how many times the largest sum appears
        largest_group_count = sum(1 for count in digit_sum_count.values() if count == max_sum)
        
        return largest_group_count

1403
from typing import List

class Solution:
    def minSubsequence(self, nums: List[int]) -> List[int]:
        total_sum = sum(nums)
        nums.sort(reverse=True)
        subsequence = []
        subsequence_sum = 0
        
        for num in nums:
            subsequence.append(num)
            subsequence_sum += num
            if subsequence_sum > total_sum / 2:
                break
        
        return subsequence

1408
from typing import List

class Solution:
    def stringMatching(self, words: List[str]) -> List[str]:
        result = []
        
        for i in range(len(words)):
            word1 = words[i]
            for j in range(len(words)):
                word2 = words[j]
                if i != j and word1 in word2 and word1 not in result:
                    result.append(word1)
        
        return result

1413
from typing import List

class Solution:
    def minStartValue(self, nums: List[int]) -> int:
        min_start_value = 1
        current_sum = 0
        
        for num in nums:
            current_sum += num
            min_start_value = max(min_start_value, 1 - current_sum)
        
        return min_start_value

1417
class Solution:
  def reformat(self, s: str) -> str:
        digits = [ch for ch in s if ch.isdigit()]
        letters = [ch for ch in s if ch.isalpha()]
        
        if abs(len(digits) - len(letters)) > 1:
            return ""
        
        result = []
        if len(digits) >= len(letters):
            for i in range(len(letters)):
                result.append(digits[i])
                result.append(letters[i])
            if len(digits) > len(letters):
                result.append(digits[-1])
        else:
            for i in range(len(digits)):
                result.append(letters[i])
                result.append(digits[i])
            if len(letters) > len(digits):
                result.append(letters[-1])
        
        return ''.join(result)

1422
class Solution:
    def maxScore(self, s: str) -> int:
        count_zeros = 0
        count_ones = s.count('1')  # Count total '1's in the string
        max_score = 0
        
        # Traverse through the string, excluding the last character
        for i in range(len(s) - 1):
            if s[i] == '0':
                count_zeros += 1
            else:
                count_ones -= 1
            
            # Calculate current score
            current_score = count_zeros + count_ones
            max_score = max(max_score, current_score)
        
        return max_score

1431
1436
from typing import List

class Solution:
    def destCity(self, paths: List[List[str]]) -> str:
        start_cities = set()
        dest_cities = set()
        
        # Collect all start and destination cities in sets
        for path in paths:
            start_cities.add(path[0])
            dest_cities.add(path[1])
        
        # Find the destination city that is not in start_cities
        for city in dest_cities:
            if city not in start_cities:
                return city
        
        return ""

1446
class Solution:
    def maxPower(self, s: str) -> int:
        if not s:
            return 0
        
        max_power = 1
        current_power = 1
        
        for i in range(1, len(s)):
            if s[i] == s[i - 1]:
                current_power += 1
            else:
                max_power = max(max_power, current_power)
                current_power = 1
        
        # Update max_power after the loop in case the longest sequence ends at the end of the string
        max_power = max(max_power, current_power)
        
        return max_power
1507
class Solution:
    def reformatDate(self, date: str) -> str:
        months = {
            "Jan": "01", "Feb": "02", "Mar": "03", "Apr": "04",
            "May": "05", "Jun": "06", "Jul": "07", "Aug": "08",
            "Sep": "09", "Oct": "10", "Nov": "11", "Dec": "12"
        }
        
        day, month, year = date.split()
        day = day[:-2] if day[1].isdigit() else '0' + day[0]
        month = months[month]
        
        return f"{year}-{month}-{day}"

1550
from typing import List

class Solution:
    def threeConsecutiveOdds(self, arr: List[int]) -> bool:
        count = 0
        for num in arr:
            if num % 2 != 0:
                count += 1
                if count == 3:
                    return True
            else:
                count = 0
        return False
1768
1935

