1
class Solution:
    def setdata(self,first,second):
        n=len(first)
        for i in range(n):
            for j in range(i+1,n+1):
                if first[i]+first[j]==second:
                    return print([i,j])
        
a=Solution()
a.setdata([2,7,11,15],9)
2
class Solution:
    def addTwoNumbers(self, l1, l2):
        self.l1=l1
        self.l2=l2
        a=0
        b=[]
        for i in range(len(l1)):
            a=l1[i]*10^i+a
        for i in range(len(l2)):
            a=a+l2[i]*10^i
        for i in range(len(str(a))):
            b.append(a%10)
            a=a//10
        return b
c=Solution()
print(c.addTwoNumbers([2,4,3],[5,6,4]))
17
from typing import List

class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits:
            return []
        
        # Mapping of digits to corresponding letters
        digit_to_char = {
            '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',
            '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'
        }
        
        # Helper function to perform backtracking
        def backtrack(index: int, path: str):
            # If the path is complete, add it to the results
            if index == len(digits):
                combinations.append(path)
                return
            
            # Get the letters that the current digit can represent
            possible_letters = digit_to_char[digits[index]]
            
            # Iterate over these letters and recurse
            for letter in possible_letters:
                backtrack(index + 1, path + letter)
        
        # List to hold the combinations
        combinations = []
        # Start the backtracking process from the first digit
        backtrack(0, "")
        
        return combinations

167
from typing import List

class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        left, right = 0, len(numbers) - 1
        
        while left < right:
            current_sum = numbers[left] + numbers[right]
            
            if current_sum == target:
                return [left + 1, right + 1]
            elif current_sum < target:
                left += 1
            else:
                right -= 1
        
        return []  # If no solution is found

class Solution:
    def romanToInt(self, s: str) -> int:
        translations = {
            "I": 1,
            "V": 5,
            "X": 10,
            "L": 50,
            "C": 100,
            "D": 500,
            "M": 1000
        }
        number = 0
        s = s.replace("IV", "IIII").replace("IX", "VIIII")
        s = s.replace("XL", "XXXX").replace("XC", "LXXXX")
        s = s.replace("CD", "CCCC").replace("CM", "DCCCC")
        for char in s:
            number += translations[char]
        return number

136
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        seen_once = set()
        seen_twice = set()
    
        for num in nums:
            if num in seen_once:
                seen_once.remove(num)
                seen_twice.add(num)
            else:
                seen_once.add(num)
    
        return seen_once.pop()

202
class Solution:
    def isHappy(self, n: int) -> bool:
        seen = set()  
        while n != 1:
            if n in seen:  # 이미 본 숫자를 만나면, 순환에 빠진 것
                return False
            seen.add(n)
            n = sum(int(digit) ** 2 for digit in str(n))  
        return True 

58
class Solution:
    def lengthOfLastWord(self, s: str) -> int:
        a=s.split()
        return len(a[-1])
169
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        n = len(nums)
        m = defaultdict(int)
        
        for num in nums:
            m[num] += 1
        
        n = n // 2
        for key, value in m.items():
            if value > n:
                return key
        
        return 0
1221
class Solution:
    def balancedStringSplit(self, s: str) -> int:
        a=0
        b=0
        c=0
        for i in s:
            if i=='L':
                a=a+1
            else:
                b=b+1
            if a==b:
                c=c+1
        return c


88
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        nums1[m:] = nums2
        nums1.sort()
        for i in range(len(nums1)-m-n):
            nums1.pop(0)
509
class Solution:
    def fib(self, n: int) -> int:
        def f(a):
            if a==0:
                return 0
            if a==1:
                return 1
            else:
                return f(a-1)+f(a-2)

        return f(n)
118
class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        triangle = []
        for i in range(numRows):
            row = [1] * (i + 1)  
            for j in range(1, i):
                row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j]
            triangle.append(row)
        return triangle
            
            
26
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        unique_values = set(nums)  # 집합으로 변환하여 중복 제거
        nums.clear()  # 기존 리스트를 비움
        nums.extend(sorted(unique_values))  # 중복이 제거된 값을 정렬하여 리스트에 추가
        return len(nums)
27
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        b=0
        while val in nums:
            nums.remove(val)
            b=b+1
        for i in range(b):
            nums.append('_')
        return len(nums)-b
88
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        nums1[m:] = nums2
        nums1.sort()
        for i in range(len(nums1)-m-n):
            nums1.pop(0)


121
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices:  # 주어진 리스트가 비어있을 경우
            return 0
        
        max_profit = 0
        min_price = prices[0]
        
        for price in prices:
            min_price = min(min_price, price)
            max_profit = max(max_profit, price - min_price)
        
        return max_profit
1768
class Solution:
    def mergeAlternately(self, word1: str, word2: str) -> str:
        a = ''
        b = len(word1)
        c = len(word2)
        for i in range(min(b, c)):
            a += word1[i]
            a += word2[i]
        if b < c:
            for i in range(b, c):  # 변경: 'for i in range(b,c)'에서 수정
                a += word2[i]
        elif b > c:
            for i in range(c, b):  # 변경: 'for i in range(c,b)'에서 수정
                a += word1[i]
        return a

1431
class Solution:
    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:
        maxs = max(candies)
        return [ x+extraCandies >=maxs for x in candies  ]
392
class Solution:
    def isIsomorphic(self, s: str, t: str) -> str:
        def count_characters(string):
            char_count = {}
            for char in string:
                if char in char_count:
                    char_count[char] += 1
                else:
                    char_count[char] = 1
            return char_count
        
        return 'true' if count_characters(s) == count_characters(t) else 'false'

290
class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        words = s.split()
        
        if len(pattern) != len(words):
            return False
        
        pattern_map = {}
        word_map = {}
        
        for char, word in zip(pattern, words):
            if char not in pattern_map:
                pattern_map[char] = word
            elif pattern_map[char] != word:
                return False
            
            if word not in word_map:
                word_map[word] = char
            elif word_map[word] != char:
                return False
        
        return True


367
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        return sqrt(num)==int(sqrt(num))
326
class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        if n <= 0:
            return False
        
        while n % 3 == 0:
            n //= 3
        
        return n == 1
344
class Solution:
    def reverseString(self, s: List[str]) -> None:
        s.reverse()

        """
        Do not return anything, modify s in-place instead.
        """
217
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        seen = set()
        for num in nums:
            if num in seen:
                return True
            seen.add(num)
        return False

231
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        if n <= 0:
            return False
        
        while n > 1:
            if n % 2 != 0:
                return False
            n //= 2
        
        return True
292
class Solution:
    def canWinNim(self, n: int) -> bool:
        return n % 4 != 0
283
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        a=0
        for i in nums:
            if 0 in nums:
                nums.remove(0)
                nums.append(0)
        """
        Do not return anything, modify nums in-place instead.
        """

228
class Solution:
    def summaryRanges(self, nums: List[int]) -> List[str]:
        if len(nums)==0:return []
        nums.append(nums[-1]+1)
        k=[]
        i=0
        while i<len(nums)-1:
            j=i
            rr=[]
            while j<len(nums)-1:
                if nums[j]+1 in nums:
                    rr.append(nums[j])
                    j+=1
                else:
                    rr.append(nums[j])
                    j+=1
                    break
            if len(rr)!=1:
                k.append(str(rr[0])+"->"+str(rr[-1]))
            else:
                k.append(str(rr[0]))
            i=j
        return k
191
class Solution:
    def hammingWeight(self, n: int) -> int:
        return bin(n).count('1')
160
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
        if not headA or not headB:
            return None

        pointerA = headA
        pointerB = headB

        while pointerA != pointerB:
            pointerA = pointerA.next if pointerA else headB
            pointerB = pointerB.next if pointerB else headA

        return pointerA
832
class Solution:
    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:
        rslt=[]
        for i in range(len(image)):
            rslt.append([])
            for j in range(len(image)):
                a=image[i]
                if a[-j-1]==0:
                    rslt[i].append(1)
                else:
                    rslt[i].append(0)
        return rslt
55
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        gas = 0
        for n in nums:
            if gas < 0:
                return False
            elif n > gas:
                gas = n
            gas -= 1
            
        return True

412
class Solution:
    
    def fizzBuzz(self, n: int) -> List[str]:
        result = []
        for i in range(1, n + 1):
            if i % 3 == 0 and i % 5 == 0:
                result.append("FizzBuzz")
            elif i % 3 == 0:
                result.append("Fizz")
            elif i % 5 == 0:
                result.append("Buzz")
            else:
                result.append(str(i))
        return result


383
class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        from collections import Counter
        
        # 잡지와 ransomNote 문자열의 문자 빈도를 카운트
        magazine_counts = Counter(magazine)
        ransomNote_counts = Counter(ransomNote)
        
        # ransomNote의 각 문자가 magazine에 충분히 있는지 확인
        for char, count in ransomNote_counts.items():
            if magazine_counts[char] < count:
                return False
        
        return True

263
class Solution:
    def isUgly(self, n: int) -> bool:
        if n <= 0:
            return False
        
        for factor in [2, 3, 5]:
            while n % factor == 0:
                n //= factor
        
        return n == 1
        
268
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        a=[]
        for i in range(len(nums)+1):
            a.append(i)
        for i in range(len(a)):
            if i not in nums:
                return i
389
class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        result = 0
        for char in s:
            result ^= ord(char)
        for char in t:
            result ^= ord(char)
        return chr(result)
504
class Solution:
    def convertToBase7(self, num: int) -> str:
        if num == 0:
            return "0"
        
        negative = num < 0
        num = abs(num)
        
        base7_digits = []
        
        while num > 0:
            base7_digits.append(str(num % 7))
            num //= 7
        
        if negative:
            base7_digits.append('-')
        
        return ''.join(base7_digits[::-1])

# Example usage:
# obj = SomeClass()
# print(obj.convertToBase7(100))  # Output: "202"
# print(obj.convertToBase7(-7))   # Output: "-10"

        
704
class Solution:
    from typing import List

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        
        return -1


896
class Solution:
    def isMonotonic(self, nums: List[int]) -> bool:
        increasing = decreasing = True
        
        for i in range(1, len(nums)):
            if nums[i] > nums[i - 1]:
                decreasing = False
            if nums[i] < nums[i - 1]:
                increasing = False
                
        return increasing or decreasing

14
from typing import List

class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ""
        
        # Start with the first string as the initial prefix
        prefix = strs[0]
        
        # Compare the prefix with each string in the list
        for string in strs[1:]:
            # Update the prefix to the common part of prefix and the current string
            while string[:len(prefix)] != prefix:
                # Trim the last character from the prefix
                prefix = prefix[:-1]
                # If prefix becomes empty, there is no common prefix
                if not prefix:
                    return ""
        
        return prefix

20
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        mapping = {')': '(', '}': '{', ']': '['}
        
        for char in s:
            if char in mapping:
                top_element = stack.pop() if stack else '#'
                if mapping[char] != top_element:
                    return False
            else:
                stack.append(char)
        
        return not stack

21
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode()
        current = dummy
        
        while list1 and list2:
            if list1.val < list2.val:
                current.next = list1
                list1 = list1.next
            else:
                current.next = list2
                list2 = list2.next
            current = current.next
        
        if list1:
            current.next = list1
        else:
            current.next = list2
        
        return dummy.next

26
27
28
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        current = head
        
        while current and current.next:
            if current.val == current.next.val:
                current.next = current.next.next
            else:
                current = current.next
        
        return head

55
67
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        result = []
        carry = 0
        i, j = len(a) - 1, len(b) - 1
        
        while i >= 0 or j >= 0 or carry:
            total = carry
            if i >= 0:
                total += int(a[i])
                i -= 1
            if j >= 0:
                total += int(b[j])
                j -= 1
            
            result.append(str(total % 2))
            carry = total // 2
        
        return ''.join(result[::-1])
        
69
83
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        current = head
        
        while current and current.next:
            if current.val == current.next.val:
                current.next = current.next.next
            else:
                current = current.next
        
        return head

88

100
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if not p and not q:
            return True
        if not p or not q:
            return False
        if p.val != q.val:
            return False
        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)

101
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        return self.isMirror(root.left, root.right)
    
    def isMirror(self, left: Optional[TreeNode], right: Optional[TreeNode]) -> bool:
        if not left and not right:
            return True
        if not left or not right:
            return False
        if left.val != right.val:
            return False
        return self.isMirror(left.left, right.right) and self.isMirror(left.right, right.left)

118
121
125
class Solution:
    def isPalindrome(self, s: str) -> bool:
        s = ''.join(filter(str.isalnum, s)).lower()
        return s == s[::-1]

160
168
class Solution:
    def convertToTitle(self, columnNumber: int) -> str:
        result = []
        while columnNumber > 0:
            columnNumber -= 1  # Adjust to 0-based index
            remainder = columnNumber % 26
            result.append(chr(remainder + ord('A')))
            columnNumber //= 26
        
        result.reverse()
        return ''.join(result)

        
169
171
class Solution:
    def titleToNumber(self, columnTitle: str) -> int:
        result = 0
        for char in columnTitle:
            result = result * 26 + (ord(char) - ord('A') + 1)
        return result

191
202
203
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        if not head:
            return None
        
        dummy = ListNode(0)
        dummy.next = head
        current = dummy
        
        while current.next:
            if current.next.val == val:
                current.next = current.next.next
            else:
                current = current.next
        
        return dummy.next

217
228
231
257
263
268
283
290
292
326
342
class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        return n > 0 and (n & (n - 1)) == 0 and (n & 0x55555555) != 0

344
345
class Solution:
    def reverseVowels(self, s: str) -> str:
        vowels = set("aeiouAEIOU")
        s = list(s)
        left, right = 0, len(s) - 1
        
        while left < right:
            if s[left] in vowels and s[right] in vowels:
                s[left], s[right] = s[right], s[left]
                left += 1
                right -= 1
            elif s[left] in vowels:
                right -= 1
            elif s[right] in vowels:
                left += 1
            else:
                left += 1
                right -= 1
        
        return ''.join(s)

349
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        set1 = set(nums1)
        set2 = set(nums2)
        
        return list(set1 & set2)
 
350
from collections import Counter
from typing import List

class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        count1 = Counter(nums1)
        count2 = Counter(nums2)
        
        intersection = []
        for num in count1:
            if num in count2:
                intersection += [num] * min(count1[num], count2[num])
        
        return intersection



350
367
383
389
392
401
from typing import List

class Solution:
    def readBinaryWatch(self, turnedOn: int) -> List[str]:
        def count_ones(num: int) -> int:
            return bin(num).count('1')
        
        results = []
        for hour in range(12):
            for minute in range(60):
                if count_ones(hour) + count_ones(minute) == turnedOn:
                    results.append(f"{hour}:{minute:02}")
        
        return results
    
682
from typing import List

class Solution:
    def calPoints(self, operations: List[str]) -> int:
        valid_points = []
        
        for op in operations:
            if op == "C":
                if valid_points:
                    valid_points.pop()
            elif op == "D":
                if valid_points:
                    valid_points.append(2 * valid_points[-1])
            elif op == "+":
                if len(valid_points) >= 2:
                    valid_points.append(valid_points[-1] + valid_points[-2])
            else:
                valid_points.append(int(op))
        
        return sum(valid_points)

405
class Solution:
    def toHex(self, num: int) -> str:
        if num == 0:
            return "0"
        
        num = num & 0xFFFFFFFF
        hex_chars = "0123456789abcdef"
        result = []
        
        while num > 0:
            result.append(hex_chars[num % 16])
            num //= 16
        
        return ''.join(result[::-1])

409
class Solution:
    def longestPalindrome(self, s: str) -> int:
        char_count = {}
        for char in s:
            if char in char_count:
                char_count[char] += 1
            else:
                char_count[char] = 1
        
        length = 0
        odd_found = False
        
        for count in char_count.values():
            if count % 2 == 0:
                length += count
            else:
                length += count - 1
                odd_found = True
        
        if odd_found:
            length += 1
        
        return length

412
415
class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        result = []
        carry = 0
        i, j = len(num1) - 1, len(num2) - 1
        
        while i >= 0 or j >= 0 or carry:
            if i >= 0:
                carry += int(num1[i])
                i -= 1
            if j >= 0:
                carry += int(num2[j])
                j -= 1
            
            result.append(str(carry % 10))
            carry //= 10
        
        return ''.join(result[::-1])

434
class Solution:
    def countSegments(self, s: str) -> int:
        segments = s.split()
        return len(segments)

441
class Solution:
    def arrangeCoins(self, n: int) -> int:
        return int((2 * n + 0.25)**0.5 - 0.5)

448
class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        for num in nums:
            index = abs(num) - 1
            nums[index] = -abs(nums[index])
        
        return [i + 1 for i in range(len(nums)) if nums[i] > 0]

455
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        
        i, j = 0, 0
        content_children = 0
        
        while i < len(g) and j < len(s):
            if s[j] >= g[i]:
                content_children += 1
                i += 1
            j += 1
        
        return content_children

459
class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        n = len(s)
        for length in range(1, n // 2 + 1):
            if n % length == 0:
                substring = s[:length]
                if substring * (n // length) == s:
                    return True
        return False

461
class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        return bin(x ^ y).count('1')

463
class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -> int:
        if not grid:
            return 0
        
        perimeter = 0
        rows, cols = len(grid), len(grid[0])
        
        for r in range(rows):
            for c in range(cols):
                if grid[r][c] == 1:
                    # Count perimeter of each land cell
                    perimeter += 4
                    # Check neighbors (up and left) and adjust perimeter
                    if r > 0 and grid[r - 1][c] == 1:
                        perimeter -= 2
                    if c > 0 and grid[r][c - 1] == 1:
                        perimeter -= 2
        
        return perimeter

944
from typing import List

class Solution:
    def minDeletionSize(self, strs: List[str]) -> int:
        num_columns = len(strs[0])
        delete_count = 0
        
        for col in range(num_columns):
            for row in range(1, len(strs)):
                if strs[row][col] < strs[row - 1][col]:
                    delete_count += 1
                    break
        
        return delete_count


257
from typing import List, Optional

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        def construct_paths(node, path):
            if node:
                path += str(node.val)
                if not node.left and not node.right:  # If it's a leaf node
                    paths.append(path)
                else:
                    path += '->'
                    construct_paths(node.left, path)
                    construct_paths(node.right, path)
        
        paths = []
        construct_paths(root, '')
        return paths

482
class Solution:
    def licenseKeyFormatting(self, s: str, k: int) -> str:
        s = s.replace('-', '').upper()
        formatted = []
        length = len(s)
        first_group_length = length % k
        
        if first_group_length:
            formatted.append(s[:first_group_length])
        
        for i in range(first_group_length, length, k):
            formatted.append(s[i:i + k])
        
        return '-'.join(formatted)

485
from typing import List

class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        max_count = 0
        current_count = 0
        
        for num in nums:
            if num == 1:
                current_count += 1
                max_count = max(max_count, current_count)
            else:
                current_count = 0
        
        return max_count
        
492
from typing import List
import math

class Solution:
    def constructRectangle(self, area: int) -> List[int]:
        w = int(math.sqrt(area))
        while area % w != 0:
            w -= 1
        l = area // w
        return [l, w]

495
from typing import List

class Solution:
    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:
        if not timeSeries:
            return 0
        
        total_duration = 0
        
        for i in range(len(timeSeries) - 1):
            total_duration += min(timeSeries[i + 1] - timeSeries[i], duration)
        
        total_duration += duration
        
        return total_duration

496
from typing import List

class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        next_greater = {}
        stack = []
        
        for num in reversed(nums2):
            while stack and stack[-1] <= num:
                stack.pop()
            if stack:
                next_greater[num] = stack[-1]
            else:
                next_greater[num] = -1
            stack.append(num)
        
        return [next_greater[num] for num in nums1]

500
from typing import List

class Solution:
    def findWords(self, words: List[str]) -> List[str]:
        row1 = set("qwertyuiop")
        row2 = set("asdfghjkl")
        row3 = set("zxcvbnm")
        
        result = []
        
        for word in words:
            lower_word = set(word.lower())
            if lower_word <= row1 or lower_word <= row2 or lower_word <= row3:
                result.append(word)
        
        return result

501
from typing import Optional, List
from collections import defaultdict

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def findMode(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []

        def inorder(node):
            if node:
                inorder(node.left)
                count[node.val] += 1
                inorder(node.right)

        count = defaultdict(int)
        inorder(root)

        max_count = max(count.values())
        return [key for key, val in count.items() if val == max_count]

504
506
from typing import List

class Solution:
    def findRelativeRanks(self, score: List[int]) -> List[str]:
        # Create a sorted list of scores in descending order
        sorted_scores = sorted(score, reverse=True)
        
        # Create a dictionary to map each score to its rank
        rank_dict = {}
        for i, s in enumerate(sorted_scores):
            if i == 0:
                rank_dict[s] = "Gold Medal"
            elif i == 1:
                rank_dict[s] = "Silver Medal"
            elif i == 2:
                rank_dict[s] = "Bronze Medal"
            else:
                rank_dict[s] = str(i + 1)
        
        # Generate the result list using the rank dictionary
        result = [rank_dict[s] for s in score]
        
        return result

507
class Solution:
    def checkPerfectNumber(self, num: int) -> bool:
        if num <= 1:
            return False

        divisors_sum = 1
        sqrt_num = int(num ** 0.5)
        
        for i in range(2, sqrt_num + 1):
            if num % i == 0:
                divisors_sum += i
                if i != num // i:
                    divisors_sum += num // i
        
        return divisors_sum == num

509
520
class Solution:
    def detectCapitalUse(self, word: str) -> bool:
        if word.isupper():
            return True
        
        if word.islower():
            return True
        
        if word[0].isupper() and word[1:].islower():
            return True
        
        return False

521
class Solution:
    def findLUSlength(self, a: str, b: str) -> int:
        if a == b:
            return -1
        else:
            return max(len(a), len(b))
  
530
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def getMinimumDifference(self, root: Optional[TreeNode]) -> int:
        self.min_diff = float('inf')
        self.prev_val = None
        
        def inorder(node):
            if not node:
                return
            
            inorder(node.left)
            
            if self.prev_val is not None:
                self.min_diff = min(self.min_diff, node.val - self.prev_val)
                
            self.prev_val = node.val
            
            inorder(node.right)
        
        inorder(root)
        
        return self.min_diff

   
541
class Solution:
    def reverseStr(self, s: str, k: int) -> str:
        ans = ""
        def helper(org=s):
            nonlocal ans
            n = 2*k
            if len(org)<k:
                ans += org[::-1]
                return
            else:
                while len(org) > k:
                    t = org[0:n]
                    org = org[n:]
                    x = t[0:k]
                    t = t[k:]
                    ans += x[::-1] + t
                if len(org) <=k:
                    ans += org[::-1]
            return
        helper()
        return ans
543
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        self.max_diameter = 0
        
        def maxDepth(node):
            if not node:
                return 0
            
            left_depth = maxDepth(node.left)
            right_depth = maxDepth(node.right)
            
            # Update max diameter found so far
            self.max_diameter = max(self.max_diameter, left_depth + right_depth)
            
            # Return the max depth of the current node
            return 1 + max(left_depth, right_depth)
        
        maxDepth(root)
        
        return self.max_diameter

551
class Solution:
    def checkRecord(self, s: str) -> bool:
        count_A = 0
        count_L = 0
        
        for char in s:
            if char == 'A':
                count_A += 1
                if count_A > 1:
                    return False
                count_L = 0  # Reset consecutive 'L' count
            elif char == 'L':
                count_L += 1
                if count_L > 2:
                    return False
            else:
                count_L = 0  # Reset consecutive 'L' count
        
        return True

557
class Solution:
    def reverseWords(self, s: str) -> str:
        words = s.split()  # 문자열을 공백을 기준으로 단어로 나눔
        reversed_words = [word[::-1] for word in words]  # 각 단어를 뒤집음
        reversed_sentence = ' '.join(reversed_words)  # 뒤집힌 단어들을 다시 문자열로 연결
        return reversed_sentence  # 결과 반환

561
from typing import List

class Solution:
    def arrayPairSum(self, nums: List[int]) -> int:
        nums.sort()  # 배열을 오름차순으로 정렬
        result = 0
        for i in range(0, len(nums), 2):
            result += nums[i]  # 짝수 인덱스의 원소들을 합산
        return result

563
class Solution:
    def findTilt(self, root: Optional[TreeNode]) -> int:
        self.tilt_sum = 0
        
        def traverse(node):
            if not node:
                return 0
            
            left_sum = traverse(node.left)
            right_sum = traverse(node.right)
            
            tilt = abs(left_sum - right_sum)
            self.tilt_sum += tilt
            
            return node.val + left_sum + right_sum
        
        traverse(root)
        
        return self.tilt_sum

566
from typing import List

class Solution:
    def matrixReshape(self, mat: List[List[int]], r: int, c: int) -> List[List[int]]:
        # Check if reshape is possible
        m = len(mat)
        n = len(mat[0]) if m > 0 else 0
        
        if m * n != r * c:
            return mat
        
        # Initialize the new reshaped matrix
        reshaped_matrix = [[0] * c for _ in range(r)]
        
        # Flatten the original matrix
        flat_matrix = [element for row in mat for element in row]
        
        # Fill the reshaped matrix
        index = 0
        for i in range(r):
            for j in range(c):
                reshaped_matrix[i][j] = flat_matrix[index]
                index += 1
        
        return reshaped_matrix

572
class Solution:
    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:
        # Helper function to check if two trees are identical
        def is_identical(s, t):
            if not s and not t:
                return True
            if not s or not t:
                return False
            return s.val == t.val and is_identical(s.left, t.left) and is_identical(s.right, t.right)
        
        # Base case: if subRoot is None, it's always considered a subtree
        if not subRoot:
            return True
        
        # Recursive function to find if subRoot is a subtree of root
        def is_subtree_with_root(s, t):
            if not s:
                return False
            return is_identical(s, t) or is_subtree_with_root(s.left, t) or is_subtree_with_root(s.right, t)
        
        return is_subtree_with_root(root, subRoot)

575
class Solution:
    def distributeCandies(self, candyType: List[int]) -> int:
        return min(len(set(candyType)), len(candyType) // 2)

594
from typing import List

class Solution:
    def findLHS(self, nums: List[int]) -> int:
        frequency = {}
        max_length = 0
        
        # Count frequencies of each number
        for num in nums:
            if num in frequency:
                frequency[num] += 1
            else:
                frequency[num] = 1
        
        # Iterate through unique numbers in nums
        for num in frequency:
            if num + 1 in frequency:
                current_length = frequency[num] + frequency[num + 1]
                max_length = max(max_length, current_length)
        
        return max_length

598
from typing import List

class Solution:
    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:
        min_rows = m
        min_cols = n
        
        for op in ops:
            a, b = op
            min_rows = min(min_rows, a)
            min_cols = min(min_cols, b)
        
        return min_rows * min_cols

599
from typing import List

class Solution:
    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:
        index_map = {}
        min_index_sum = float('inf')
        result = []
        
        # Store indices of restaurants in list1
        for index, restaurant in enumerate(list1):
            index_map[restaurant] = index
        
        # Find common restaurants and calculate index sum
        for index, restaurant in enumerate(list2):
            if restaurant in index_map:
                current_index_sum = index + index_map[restaurant]
                if current_index_sum < min_index_sum:
                    min_index_sum = current_index_sum
                    result = [restaurant]
                elif current_index_sum == min_index_sum:
                    result.append(restaurant)
        
        return result

617
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root1:
            return root2
        if not root2:
            return root1
        
        # Create a new node with the sum of values from root1 and root2
        merged_root = TreeNode(root1.val + root2.val)
        
        # Recursively merge left and right subtrees
        merged_root.left = self.mergeTrees(root1.left, root2.left)
        merged_root.right = self.mergeTrees(root1.right, root2.right)
        
        return merged_root
      
628
from typing import List

class Solution:
    def maximumProduct(self, nums: List[int]) -> int:
        nums.sort()
        return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])

637
from typing import List, Optional
from collections import deque

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:
        if not root:
            return []
        
        averages = []
        queue = deque([root])
        
        while queue:
            level_sum = 0
            level_count = len(queue)
            
            for _ in range(level_count):
                node = queue.popleft()
                level_sum += node.val
                
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            
            averages.append(level_sum / level_count)
        
        return averages

643
from typing import List

class Solution:
    def findMaxAverage(self, nums: List[int], k: int) -> float:
        max_sum = current_sum = sum(nums[:k])
        
        for i in range(k, len(nums)):
            current_sum += nums[i] - nums[i - k]
            if current_sum > max_sum:
                max_sum = current_sum
        
        return max_sum / k

645
from typing import List

class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        num_set = set()
        duplicate = -1
        n = len(nums)
        actual_sum = sum(nums)
        
        for num in nums:
            if num in num_set:
                duplicate = num
            num_set.add(num)
        
        expected_sum = n * (n + 1) // 2
        missing = expected_sum - (actual_sum - duplicate)
        
        return [duplicate, missing]

653
from typing import Optional, Set

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def findTarget(self, root: Optional[TreeNode], k: int) -> bool:
        def find(node, seen: Set[int]) -> bool:
            if not node:
                return False
            if k - node.val in seen:
                return True
            seen.add(node.val)
            return find(node.left, seen) or find(node.right, seen)
        
        return find(root, set())

657
class Solution:
    def judgeCircle(self, moves: str) -> bool:
        x, y = 0, 0

        for move in moves:
            if move == 'U':
                y += 1
            elif move == 'D':
                y -= 1
            elif move == 'L':
                x -= 1
            elif move == 'R':
                x += 1

        return x == 0 and y == 0
        
661
from typing import List

class Solution:
    def imageSmoother(self, img: List[List[int]]) -> List[List[int]]:
        rows = len(img)
        cols = len(img[0])
        
        smoothed_img = [[0] * cols for _ in range(rows)]
        
        directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 0), (0, 1), (1, -1), (1, 0), (1, 1)]
        
        for i in range(rows):
            for j in range(cols):
                sum_val = 0
                count = 0
                
                for d in directions:
                    ni, nj = i + d[0], j + d[1]
                    if 0 <= ni < rows and 0 <= nj < cols:
                        sum_val += img[ni][nj]
                        count += 1
                
                smoothed_img[i][j] = sum_val // count
        
        return smoothed_img

671
from typing import Optional

# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def findSecondMinimumValue(self, root: Optional[TreeNode]) -> int:
        def dfs(node):
            nonlocal first_min, second_min
            
            if not node:
                return
            
            # Update first_min and second_min based on current node's value
            if node.val < first_min:
                second_min = first_min
                first_min = node.val
            elif first_min < node.val < second_min:
                second_min = node.val
            
            # Recursively visit left and right children
            dfs(node.left)
            dfs(node.right)
        
        # Initialize first_min and second_min to infinity
        first_min = float('inf')
        second_min = float('inf')
        
        # Start DFS from the root
        dfs(root)
        
        # If second_min is still infinity, it means no second minimum value found
        return second_min if second_min != float('inf') else -1

674
from typing import List

class Solution:
    def findLengthOfLCIS(self, nums: List[int]) -> int:
        if not nums:
            return 0
        
        max_length = 1
        current_length = 1
        
        for i in range(1, len(nums)):
            if nums[i] > nums[i - 1]:
                current_length += 1
            else:
                if current_length > max_length:
                    max_length = current_length
                current_length = 1
        
        if current_length > max_length:
            max_length = current_length
        
        return max_length

680
class Solution:
    def validPalindrome(self, s: str) -> bool:
        def is_palindrome(s, left, right):
            while left < right:
                if s[left] != s[right]:
                    return False
                left += 1
                right -= 1
            return True
        
        left, right = 0, len(s) - 1
        
        while left < right:
            if s[left] != s[right]:
                return is_palindrome(s, left + 1, right) or is_palindrome(s, left, right - 1)
            left += 1
            right -= 1
        
        return True

682
693
class Solution:
    def hasAlternatingBits(self, n: int) -> bool:
        previous_bit = n & 0x1  # Get the least significant bit of n
        n >>= 1  # Shift n to the right by 1 bit
        
        while n > 0:
            current_bit = n & 0x1  # Get the least significant bit of n after shifting
            if current_bit == previous_bit:
                return False
            previous_bit = current_bit
            n >>= 1  # Shift n to the right by 1 bit
        
        return True

696
class Solution:
    def countBinarySubstrings(self, s: str) -> int:
        prev_length = 0
        cur_length = 1
        count = 0
        
        for i in range(1, len(s)):
            if s[i] == s[i - 1]:
                cur_length += 1
            else:
                count += min(prev_length, cur_length)
                prev_length = cur_length
                cur_length = 1
        
        count += min(prev_length, cur_length)
        
        return count

697
from collections import defaultdict

class Solution:
    def findShortestSubArray(self, nums: List[int]) -> int:
        freq = defaultdict(int)
        first_index = {}
        degree = 0
        min_length = len(nums)
        
        for i, num in enumerate(nums):
            freq[num] += 1
            if num not in first_index:
                first_index[num] = i
        
        degree = max(freq.values())
        
        for num, count in freq.items():
            if count == degree:
                start = first_index[num]
                end = len(nums) - nums[::-1].index(num) - 1
                min_length = min(min_length, end - start + 1)
        
        return min_length

700
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        # Base case: if root is None or we found the node
        if root is None or root.val == val:
            return root
        
        # Recursive cases
        if val < root.val:
            return self.searchBST(root.left, val)
        else:
            return self.searchBST(root.right, val)

704
709
class Solution:
    def toLowerCase(self, s: str) -> str:
        return s.lower()

717
from typing import List

class Solution:
    def isOneBitCharacter(self, bits: List[int]) -> bool:
        i = 0
        while i < len(bits) - 1:
            if bits[i] == 0:
                i += 1  # Move one step forward for one-bit character
            else:
                i += 2  # Move two steps forward for two-bit character
        
        return i == len(bits) - 1

724
from typing import List

class Solution:
    def pivotIndex(self, nums: List[int]) -> int:
        total_sum = sum(nums)
        left_sum = 0
        
        for i in range(len(nums)):
            right_sum = total_sum - left_sum - nums[i]
            if left_sum == right_sum:
                return i
            left_sum += nums[i]
        
        return -1

728
from typing import List

class Solution:
    def selfDividingNumbers(self, left: int, right: int) -> List[int]:
        def is_self_dividing(num):
            for digit in str(num):
                if digit == '0' or num % int(digit) != 0:
                    return False
            return True
        
        result = []
        for num in range(left, right + 1):
            if is_self_dividing(num):
                result.append(num)
        
        return result

733
from typing import List

class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
        def fill(image, sr, sc, color, newColor):
            if sr < 0 or sr >= len(image) or sc < 0 or sc >= len(image[0]) or image[sr][sc] != color:
                return
            image[sr][sc] = newColor
            fill(image, sr + 1, sc, color, newColor)
            fill(image, sr - 1, sc, color, newColor)
            fill(image, sr, sc + 1, color, newColor)
            fill(image, sr, sc - 1, color, newColor)
        
        if image[sr][sc] == newColor:
            return image
        
        fill(image, sr, sc, image[sr][sc], newColor)
        
        return image

744
from typing import List

class Solution:
    def nextGreatestLetter(self, letters: List[str], target: str) -> str:
        low, high = 0, len(letters) - 1
        
        while low <= high:
            mid = (low + high) // 2
            if letters[mid] <= target:
                low = mid + 1
            else:
                high = mid - 1
        
        # After the loop, low is the index of the smallest element greater than target
        return letters[low % len(letters)]

746
from typing import List

class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        n = len(cost)
        if n == 0:
            return 0
        if n == 1:
            return cost[0]
        
        dp = [0] * n
        dp[0] = cost[0]
        dp[1] = cost[1]
        
        for i in range(2, n):
            dp[i] = cost[i] + min(dp[i-1], dp[i-2])
        
        return min(dp[n-1], dp[n-2])

747
from typing import List

class Solution:
    def dominantIndex(self, nums: List[int]) -> int:
        max_num = -1
        max_idx = -1
        second_max = -1
        
        # Find the maximum and second maximum
        for i in range(len(nums)):
            if nums[i] > max_num:
                second_max = max_num
                max_num = nums[i]
                max_idx = i
            elif nums[i] > second_max:
                second_max = nums[i]
        
        # Check if max_num is at least twice as large as every other number
        for num in nums:
            if num != max_num and max_num < 2 * num:
                return -1
        
        return max_idx

748
from typing import List
import collections

class Solution:
    def shortestCompletingWord(self, licensePlate: str, words: List[str]) -> str:
        # Normalize licensePlate
        licensePlate = licensePlate.lower()
        license_count = collections.Counter(c for c in licensePlate if c.isalpha())
        
        shortest_word = None
        min_length = float('inf')
        
        for word in words:
            word_count = collections.Counter(word)
            if all(word_count[char] >= license_count[char] for char in license_count):
                if len(word) < min_length:
                    shortest_word = word
                    min_length = len(word)
        
        return shortest_word

762
class Solution:
    def countPrimeSetBits(self, left: int, right: int) -> int:
        def is_prime(n):
            if n <= 1:
                return False
            if n <= 3:
                return True
            if n % 2 == 0 or n % 3 == 0:
                return False
            i = 5
            while i * i <= n:
                if n % i == 0 or n % (i + 2) == 0:
                    return False
                i += 6
            return True
        
        # Set of prime numbers up to 20 (max bits for right=10^6)
        prime_set = set([2, 3, 5, 7, 11, 13, 17, 19])
        
        count = 0
        for num in range(left, right + 1):
            bit_count = bin(num).count('1')
            if bit_count in prime_set:
                count += 1
        
        return count

766
from typing import List

class Solution:
    def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:
        rows = len(matrix)
        cols = len(matrix[0])
        
        # Check each element against its bottom-right neighbor
        for i in range(rows - 1):
            for j in range(cols - 1):
                if matrix[i][j] != matrix[i + 1][j + 1]:
                    return False
        
        return True

771
class Solution:
    def numJewelsInStones(self, jewels: str, stones: str) -> int:
        jewels_set = set(jewels)
        count = 0
        
        for stone in stones:
            if stone in jewels_set:
                count += 1
        
        return count


783
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def minDiffInBST(self, root: TreeNode) -> int:
        self.prev = None
        self.min_diff = float('inf')
        
        def inorder(node):
            if node is None:
                return
            
            inorder(node.left)
            
            if self.prev is not None:
                self.min_diff = min(self.min_diff, node.val - self.prev)
            
            self.prev = node.val
            
            inorder(node.right)
        
        inorder(root)
        
        return self.min_diff

796
from typing import List
import math

class Solution:
    def constructRectangle(self, area: int) -> List[int]:
        w = int(math.sqrt(area))
        while area % w != 0:
            w -= 1
        l = area // w
        return [l, w]

804
class Solution:
    def uniqueMorseRepresentations(self, words: List[str]) -> int:
        morse_mapping = [".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..", ".---", 
                         "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.", "...", "-", 
                         "..-", "...-", ".--", "-..-", "-.--", "--.."]
        
        unique_codes = set()
        
        for word in words:
            morse_code = []
            for char in word:
                morse_code.append(morse_mapping[ord(char) - ord('a')])
            morse_representation = ''.join(morse_code)
            unique_codes.add(morse_representation)
        
        return len(unique_codes)
806
class Solution:
    def numberOfLines(self, widths: List[int], s: str) -> List[int]:
        lines_used = 1
        current_width = 0
        
        for char in s:
            width = widths[ord(char) - ord('a')]
            if current_width + width > 100:
                lines_used += 1
                current_width = width
            else:
                current_width += width
        
        return [lines_used, current_width]

812
class Solution:
    def largestTriangleArea(self, points: List[List[int]]) -> float:
        def triangle_area(p1, p2, p3):
            x1, y1 = p1
            x2, y2 = p2
            x3, y3 = p3
            return 0.5 * abs(x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2))
        
        n = len(points)
        max_area = 0.0
        
        for i in range(n):
            for j in range(i + 1, n):
                for k in range(j + 1, n):
                    p1 = points[i]
                    p2 = points[j]
                    p3 = points[k]
                    area = triangle_area(p1, p2, p3)
                    max_area = max(max_area, area)
        
        return max_area

819
import re
from collections import Counter

class Solution:
    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
        normalized_paragraph = re.sub(r'[^\w\s]', ' ', paragraph.lower())
        words = normalized_paragraph.split()
        words = [word for word in words if word not in set(banned)]
        word_count = Counter(words)
        
        most_common_word = ''
        max_frequency = 0
        for word, freq in word_count.items():
            if freq > max_frequency:
                most_common_word = word
                max_frequency = freq
        
        return most_common_word

821
class Solution:
    def shortestToChar(self, s: str, c: str) -> List[int]:
        n = len(s)
        positions = []
        
        for i in range(n):
            if s[i] == c:
                positions.append(i)
        
        distances = [0] * n
        for i in range(n):
            if s[i] != c:
                distances[i] = min(abs(i - pos) for pos in positions)
        
        return distances

824
class Solution:
    def toGoatLatin(self, sentence: str) -> str:
        vowels = set('aeiouAEIOU')
        words = sentence.split()
        result = []
        
        for i, word in enumerate(words, start=1):
            if word[0] in vowels:
                goat_word = word + 'ma'
            else:
                goat_word = word[1:] + word[0] + 'ma'
                
            goat_word += 'a' * i
            result.append(goat_word)
        
        return ' '.join(result)

830
class Solution:
    def largeGroupPositions(self, s: str) -> List[List[int]]:
        n = len(s)
        result = []
        start = 0
        
        for i in range(1, n):
            if s[i] != s[i - 1]:
                if i - start >= 3:
                    result.append([start, i - 1])
                start = i
        
        # Check the last group if it extends to the end of the string
        if n - start >= 3:
            result.append([start, n - 1])
        
        return result

832
836
class Solution:
    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:
        x1, y1, x2, y2 = rec1
        x3, y3, x4, y4 = rec2
        
        if x2 <= x3 or x1 >= x4 or y2 <= y3 or y1 >= y4:
            return False
        else:
            return True

844
class Solution:
    def backspaceCompare(self, s: str, t: str) -> bool:
        def process_string(s):
            result_list = []
            for char in s:
                if char != '#':
                    result_list.append(char)
                elif result_list:
                    result_list.pop()
            return ''.join(result_list)
        
        return process_string(s) == process_string(t)

859
class Solution:
    def buddyStrings(self, s: str, goal: str) -> bool:
        if len(s) != len(goal):
            return False
        
        if s == goal:
            seen = set()
            for char in s:
                if char in seen:
                    return True
                seen.add(char)
            return False
        
        mismatch_indices = []
        for i in range(len(s)):
            if s[i] != goal[i]:
                mismatch_indices.append(i)
        
        if len(mismatch_indices) != 2:
            return False
        
        i, j = mismatch_indices
        return s[i] == goal[j] and s[j] == goal[i]

860
class Solution:
    def lemonadeChange(self, bills: List[int]) -> bool:
        five_count = 0
        ten_count = 0
        
        for bill in bills:
            if bill == 5:
                five_count += 1
            elif bill == 10:
                if five_count > 0:
                    five_count -= 1
                    ten_count += 1
                else:
                    return False
            elif bill == 20:
                if ten_count > 0 and five_count > 0:
                    ten_count -= 1
                    five_count -= 1
                elif five_count >= 3:
                    five_count -= 3
                else:
                    return False
        
        return True

867
class Solution:
    def transpose(self, matrix: List[List[int]]) -> List[List[int]]:
        m = len(matrix)      # number of rows in original matrix
        n = len(matrix[0])   # number of columns in original matrix
        
        # Initialize the transpose matrix with dimensions n x m
        result = [[0] * m for _ in range(n)]
        
        # Fill the transpose matrix
        for i in range(m):
            for j in range(n):
                result[j][i] = matrix[i][j]
        
        return result

868
class Solution:
    def binaryGap(self, n: int) -> int:
        binary_str = bin(n)[2:]
        
        max_gap = 0
        current_gap = 0
        found_one = False
        
        for char in binary_str:
            if char == '1':
                if not found_one:
                    found_one = True
                else:
                    max_gap = max(max_gap, current_gap)
                current_gap = 1
            elif found_one:
                current_gap += 1
        
        return max_gap
872
class Solution:
    def leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:
        def get_leaf_sequence(root: Optional[TreeNode]) -> List[int]:
            result = []
            stack = [root]
            
            while stack:
                node = stack.pop()
                if node:
                    if not node.left and not node.right:
                        result.append(node.val)
                    else:
                        stack.append(node.right)
                        stack.append(node.left)
            
            return result
        
        return get_leaf_sequence(root1) == get_leaf_sequence(root2)

876
class Solution:
    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head:
            return None
        
        slow = head
        fast = head
        
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        
        return slow

883
class Solution:
    def projectionArea(self, grid: List[List[int]]) -> int:
        xy_area = sum(1 for row in grid for cell in row if cell > 0)
        xz_area = sum(max(row) for row in grid)
        yz_area = sum(max(row[i] for row in grid) for i in range(len(grid[0])))
        
        return xy_area + xz_area + yz_area

884
class Solution:
    def uncommonFromSentences(self, s1: str, s2: str) -> List[str]:
        word_count = {}
        
        # Split sentences into words and count occurrences
        words1 = s1.split()
        words2 = s2.split()
        
        for word in words1:
            if word in word_count:
                word_count[word] += 1
            else:
                word_count[word] = 1
        
        for word in words2:
            if word in word_count:
                word_count[word] += 1
            else:
                word_count[word] = 1
        
        # Find uncommon words (words that appear exactly once)
        uncommon_words = []
        for word, count in word_count.items():
            if count == 1:
                uncommon_words.append(word)
        
        return uncommon_words

888
class Solution:
    def fairCandySwap(self, aliceSizes: List[int], bobSizes: List[int]) -> List[int]:
        sum_Alice = sum(aliceSizes)
        sum_Bob = sum(bobSizes)
        
        set_Bob = set(bobSizes)
        
        target_diff = (sum_Alice - sum_Bob) // 2
        
        for x in aliceSizes:
            y = x - target_diff
            if y in set_Bob:
                return [x, y]

896
897
class Solution:
    def increasingBST(self, root: TreeNode) -> TreeNode:
        def inorder(node):
            nonlocal current
            
            if not node:
                return
            
            inorder(node.left)
            
            # Process current node
            node.left = None
            current.right = node
            current = node
            
            inorder(node.right)
        
        # Create a dummy node to hold the head of the new tree
        dummy = TreeNode(-1)
        current = dummy
        
        inorder(root)
        
        # Return the right child of dummy, which is the head of the new tree
        return dummy.right

905
class Solution:
    def sortArrayByParity(self, nums: List[int]) -> List[int]:
        left, right = 0, len(nums) - 1
        
        while left < right:
            if nums[left] % 2 != 0:  # nums[left] is odd
                if nums[right] % 2 == 0:  # nums[right] is even
                    # Swap nums[left] and nums[right]
                    nums[left], nums[right] = nums[right], nums[left]
                right -= 1
            else:
                left += 1
        
        return nums

908
class Solution:
    def smallestRangeI(self, nums: List[int], k: int) -> int:
        min_num = min(nums)
        max_num = max(nums)
        
        min_possible_range = max_num - k - (min_num + k)
        
        return max(0, min_possible_range)

914
from collections import Counter
from math import gcd
from functools import reduce

class Solution:
    def hasGroupsSizeX(self, deck: List[int]) -> bool:
        count = Counter(deck)
        values = list(count.values())
        
        def find_gcd(a, b):
            return gcd(a, b)
        
        gcd_value = reduce(find_gcd, values)
        
        return gcd_value > 1

917
class Solution:
    def reverseOnlyLetters(self, s: str) -> str:
        s_list = list(s)
        left, right = 0, len(s) - 1
        
        while left < right:
            if s_list[left].isalpha() and s_list[right].isalpha():
                # Swap characters
                s_list[left], s_list[right] = s_list[right], s_list[left]
                left += 1
                right -= 1
            elif not s_list[left].isalpha():
                left += 1
            elif not s_list[right].isalpha():
                right -= 1
        
        return ''.join(s_list)

922
class Solution:
    def sortArrayByParityII(self, nums: List[int]) -> List[int]:
        n = len(nums)
        even_index, odd_index = 0, 1
        
        while even_index < n and odd_index < n:
            if nums[even_index] % 2 == 0:
                even_index += 2
            elif nums[odd_index] % 2 == 1:
                odd_index += 2
            else:
                # Swap nums[even_index] and nums[odd_index]
                nums[even_index], nums[odd_index] = nums[odd_index], nums[even_index]
                even_index += 2
                odd_index += 2
        
        return nums

925
class Solution:
    def isLongPressedName(self, name: str, typed: str) -> bool:
        i, j = 0, 0
        n, m = len(name), len(typed)
        
        while j < m:
            if i < n and name[i] == typed[j]:
                i += 1
                j += 1
            elif j > 0 and typed[j] == typed[j-1]:
                j += 1
            else:
                return False
        
        return i == n

929
class Solution:
    def numUniqueEmails(self, emails: List[str]) -> int:
        unique_emails = set()
        
        for email in emails:
            local_name, domain_name = email.split('@')
            
            # Normalize local name
            local_name = local_name.split('+')[0]  # Ignore everything after '+'
            local_name = local_name.replace('.', '')  # Remove all '.'
            
            # Construct normalized email
            normalized_email = local_name + '@' + domain_name
            
            # Add to set to ensure uniqueness
            unique_emails.add(normalized_email)
        
        return len(unique_emails)

938
class Solution:
    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:
        def dfs(node, low, high):
            if not node:
                return 0
            
            if node.val < low:
                return dfs(node.right, low, high)
            elif node.val > high:
                return dfs(node.left, low, high)
            else:
                return node.val + dfs(node.left, low, high) + dfs(node.right, low, high)
        
        return dfs(root, low, high)

941
class Solution:
    def validMountainArray(self, arr: List[int]) -> bool:
        n = len(arr)
        
        if n < 3:
            return False
        
        peak_index = arr.index(max(arr))
        
        if peak_index == 0 or peak_index == n - 1:
            return False
        
942
class Solution:
    def diStringMatch(self, s: str) -> List[int]:
        n = len(s)
        low, high = 0, n
        result = []
        
        for char in s:
            if char == 'I':
                result.append(low)
                low += 1
            elif char == 'D':
                result.append(high)
                high -= 1
        
        # Append the last remaining number
        result.append(low)
        
        return result

944
953
class Solution:
    def isAlienSorted(self, words: List[str], order: str) -> bool:
        order_map = {char: idx for idx, char in enumerate(order)}
        
        def is_sorted(w1, w2):
            for c1, c2 in zip(w1, w2):
                if order_map[c1] > order_map[c2]:
                    return False
                elif order_map[c1] < order_map[c2]:
                    break
            else:
                return len(w1) <= len(w2)
            return True
        
        for i in range(len(words) - 1):
            if not is_sorted(words[i], words[i + 1]):
                return False
        
        return True

961
class Solution:
    def repeatedNTimes(self, nums: List[int]) -> int:
        N = len(nums) // 2
        freq_map = {}
        
        for num in nums:
            if num in freq_map:
                freq_map[num] += 1
                if freq_map[num] == N:
                    return num
            else:
                freq_map[num] = 1

965
class Solution:
    def isUnivalTree(self, root: Optional[TreeNode]) -> bool:
        def is_unival(node, value):
            if not node:
                return True
            if node.val != value:
                return False
            return is_unival(node.left, value) and is_unival(node.right, value)
        
        if not root:
            return True
        return is_unival(root, root.val)

976
class Solution:
    def largestPerimeter(self, nums: List[int]) -> int:
        nums.sort(reverse=True)
        
        for i in range(len(nums) - 2):
            if nums[i] < nums[i + 1] + nums[i + 2]:
                return nums[i] + nums[i + 1] + nums[i + 2]
        
        return 0

977
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        n = len(nums)
        result = [0] * n
        left, right = 0, n - 1
        idx = n - 1
        
        while left <= right:
            left_square = nums[left] ** 2
            right_square = nums[right] ** 2
            
            if left_square > right_square:
                result[idx] = left_square
                left += 1
            else:
                result[idx] = right_square
                right -= 1
            idx -= 1
        
        return result

989
class Solution:
    def addToArrayForm(self, num: List[int], k: int) -> List[int]:
        result = []
        carry = 0
        
        while num or k > 0:
            if num:
                digit = num.pop()
            else:
                digit = 0
            
            total = digit + (k % 10) + carry
            carry = total // 10
            result.append(total % 10)
            
            k //= 10
        
        if carry:
            result.append(carry)
        
        return result[::-1]

993
class Solution:
    def isCousins(self, root: Optional[TreeNode], x: int, y: int) -> bool:
        x_parent, x_depth = None, -1
        y_parent, y_depth = None, -1
        
        def dfs(node, parent, depth):
            nonlocal x_parent, x_depth, y_parent, y_depth
            
            if not node:
                return
            
            if node.val == x:
                x_parent, x_depth = parent, depth
            elif node.val == y:
                y_parent, y_depth = parent, depth
            
            # Early return if both x and y are found
            if x_parent is not None and y_parent is not None:
                return
            
            dfs(node.left, node, depth + 1)
            dfs(node.right, node, depth + 1)
        
        dfs(root, None, 0)
        
        return x_depth == y_depth and x_parent != y_parent

997
class Solution:
    def findJudge(self, n: int, trust: List[List[int]]) -> int:
        trust_count = [0] * (n + 1)
        trusted_by_count = [0] * (n + 1)
        
        for a, b in trust:
            trust_count[a] -= 1
            trusted_by_count[b] += 1
        
        for i in range(1, n + 1):
            if trust_count[i] == 0 and trusted_by_count[i] == n - 1:
                return i
        
        return -1

999
class Solution:
    def numRookCaptures(self, board: List[List[str]]) -> int:
        n = len(board)
        rook_pos = None
        for i in range(n):
            for j in range(n):
                if board[i][j] == 'R':
                    rook_pos = (i, j)
                    break
            if rook_pos:
                break
        
        if not rook_pos:
            return 0
        
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        count = 0
        
        for d in directions:
            x, y = rook_pos
            dx, dy = d
            while 0 <= x + dx < n and 0 <= y + dy < n:
                x += dx
                y += dy
                if board[x][y] == 'B':
                    break
                if board[x][y] == 'p':
                    count += 1
                    break
        
        return count

1108
1619
from typing import List

class Solution:
    def trimMean(self, arr: List[int]) -> float:
        arr.sort()
        n = len(arr)
        remove_count = int(n * 0.05)
        trimmed_arr = arr[remove_count : n - remove_count]
        trimmed_mean = sum(trimmed_arr) / len(trimmed_arr)
        return trimmed_mean

1122
from typing import List
from collections import Counter

class Solution:
    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:
        counter = Counter(arr1)
        result = []
        
        for num in arr2:
            result.extend([num] * counter.pop(num, 0))
        
        rest = sorted(counter.elements())
        result.extend(rest)
        
        return result

1287
from typing import List

class Solution:
    def findSpecialInteger(self, arr: List[int]) -> int:
        threshold = len(arr) // 4
        count = 1

        for i in range(1, len(arr)):
            if arr[i] == arr[i - 1]:
                count += 1
                if count > threshold:
                    return arr[i]
            else:
                count = 1

        return arr[0]

1128
from typing import List
from collections import defaultdict

class Solution:
    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:
        count = defaultdict(int)
        pairs = 0

        for a, b in dominoes:
            key = tuple(sorted((a, b)))
            pairs += count[key]
            count[key] += 1

        return pairs

1137
class Solution:
    def tribonacci(self, n: int) -> int:
        if n == 0:
            return 0
        elif n == 1 or n == 2:
            return 1
        t0, t1, t2 = 0, 1, 1
        for i in range(3, n + 1):
            t3 = t0 + t1 + t2
            t0, t1, t2 = t1, t2, t3
        
        return t2
1331
from typing import List

class Solution:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        if not arr:
            return []
        
        sorted_arr = sorted(set(arr))
        rank_map = {num: rank + 1 for rank, num in enumerate(sorted_arr)}
        
        return [rank_map[num] for num in arr]

1154
class Solution:
    def dayOfYear(self, date: str) -> int:
        year, month, day = map(int, date.split('-'))
        
        days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        
        if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
            days_in_month[1] = 29
        
        return sum(days_in_month[:month - 1]) + day

1935
class Solution:
    def canBeTypedWords(self, text: str, brokenLetters: str) -> int:
        broken_set = set(brokenLetters)
        words = text.split()
        count = 0
        
        for word in words:
            if not any(char in broken_set for char in word):
                count += 1
        
        return count

1360
from datetime import datetime

class Solution:
    def daysBetweenDates(self, date1: str, date2: str) -> int:
        # Parse input dates into datetime objects
        date_format = "%Y-%m-%d"
        d1 = datetime.strptime(date1, date_format).date()
        d2 = datetime.strptime(date2, date_format).date()
        
        # Calculate the difference in days
        delta = abs(d2 - d1).days
        
        return delta

1175
class Solution:
    def numPrimeArrangements(self, n: int) -> int:
        MOD = 10**9 + 7
        
        def is_prime(num):
            if num <= 1:
                return False
            if num <= 3:
                return True
            if num % 2 == 0 or num % 3 == 0:
                return False
            i = 5
            while i * i <= num:
                if num % i == 0 or num % (i + 2) == 0:
                    return False
                i += 6
            return True
        
        count_primes = sum(1 for i in range(1, n + 1) if is_prime(i))
        
        def factorial(num):
            if num <= 1:
                return 1
            result = 1
            for i in range(2, num + 1):
                result = (result * i) % MOD
            return result
        
        prime_factorial = factorial(count_primes)
        non_prime_factorial = factorial(n - count_primes)
        
        return (prime_factorial * non_prime_factorial) % MOD

1184
from typing import List

class Solution:
    def distanceBetweenBusStops(self, distance: List[int], start: int, destination: int) -> int:
        if start > destination:
            start, destination = destination, start
        
        clockwise_distance = sum(distance[start:destination])
        counterclockwise_distance = sum(distance[destination:] + distance[:start])
        
        return min(clockwise_distance, counterclockwise_distance)

1185
from datetime import datetime

class Solution:
    def dayOfTheWeek(self, day: int, month: int, year: int) -> str:
        # Create a datetime object for the given date
        date_object = datetime(year, month, day)
        
        # Get the day of the week as a string (Monday, Tuesday, etc.)
        day_of_week = date_object.strftime("%A")
        
        return day_of_week

1189
from collections import Counter

class Solution:
    def maxNumberOfBalloons(self, text: str) -> int:
        balloon_counts = {'b': 1, 'a': 1, 'l': 2, 'o': 2, 'n': 1}
        text_counts = Counter(text)
        max_balloons = float('inf')
        
        for char, count in balloon_counts.items():
            max_balloons = min(max_balloons, text_counts.get(char, 0) // count)
1200
from typing import List

class Solution:
    def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:
        arr.sort()
        min_abs_diff = float('inf')
        result = []
        
        for i in range(1, len(arr)):
            abs_diff = arr[i] - arr[i - 1]
            
            if abs_diff < min_abs_diff:
                min_abs_diff = abs_diff
                result = [[arr[i - 1], arr[i]]]
            elif abs_diff == min_abs_diff:
                result.append([arr[i - 1], arr[i]])
        
        return result

1207
from typing import List

class Solution:
    def uniqueOccurrences(self, arr: List[int]) -> bool:
        count_map = {}
        for num in arr:
            if num in count_map:
                count_map[num] += 1
            else:
                count_map[num] = 1
        
        occurrence_counts = count_map.values()
        return len(occurrence_counts) == len(set(occurrence_counts))

1217
from typing import List

class Solution:
    def minCostToMoveChips(self, position: List[int]) -> int:
        even_count = sum(1 for pos in position if pos % 2 == 0)
        odd_count = len(position) - even_count
        
        return min(even_count, odd_count)

1221
1287
1309
class Solution:
    def freqAlphabets(self, s: str) -> str:
        result = []
        i = 0
        while i < len(s):
            if i + 2 < len(s) and s[i + 2] == '#':
                # Decode two-digit number
                num = int(s[i:i + 2])
                result.append(chr(ord('a') + num - 1))
                i += 3
            else:
                # Decode single-digit number
                num = int(s[i])
                result.append(chr(ord('a') + num - 1))
                i += 1
        
        return ''.join(result)

1313
from typing import List

class Solution:
    def decompressRLElist(self, nums: List[int]) -> List[int]:
        result = []
        for i in range(0, len(nums), 2):
            freq = nums[i]
            value = nums[i + 1]
            result.extend([value] * freq)
        return result

1317
from typing import List

class Solution:
    def getNoZeroIntegers(self, n: int) -> List[int]:
        def contains_zero_digit(num):
            return '0' in str(num)
        
        for i in range(1, n):
            if not contains_zero_digit(i) and not contains_zero_digit(n - i):
                return [i, n - i]
        
        return []
1323
class Solution:
    def maximum69Number (self, num: int) -> int:
        num_str = str(num)
        for i in range(len(num_str)):
            if num_str[i] == '6':
                num_str = num_str[:i] + '9' + num_str[i+1:]
                break
        return int(num_str)

1331
1332
class Solution:
    def removePalindromeSub(self, s: str) -> int:
        if not s:
            return 0
        
        if s == s[::-1]:
            return 1
        
        return 2

1337
from typing import List

class Solution:
    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:
        # Calculate the strength (number of 1s) for each row
        row_strength = []
        for i in range(len(mat)):
            strength = sum(mat[i])
            row_strength.append((i, strength))
        
        # Sort rows by strength (number of 1s)
        row_strength.sort(key=lambda x: x[1])
        
        # Extract indices of the k weakest rows
        result = [row_strength[i][0] for i in range(k)]
        
        return result

1342
class Solution:
    def numberOfSteps(self, num: int) -> int:
        steps = 0
        while num > 0:
            if num % 2 == 0:
                num //= 2
            else:
                num -= 1
            steps += 1
        return steps

1346
from typing import List

class Solution:
    def checkIfExist(self, arr: List[int]) -> bool:
        seen = set()
        for num in arr:
            if 2 * num in seen or (num % 2 == 0 and num // 2 in seen):
                return True
            seen.add(num)
        return False

1356
from typing import List

class Solution:
    def sortByBits(self, arr: List[int]) -> List[int]:
        def count_ones(num):
            return bin(num).count('1')
        
        # Sort by number of 1's in binary representation, then by the number itself
        return sorted(arr, key=lambda x: (count_ones(x), x))

1360
1365
from typing import List

class Solution:
    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:
        # Create a copy of nums and sort it
        sorted_nums = sorted(nums)
        
        # Create a dictionary to store the count of smaller numbers for each unique number
        count_smaller = {}
        for i, num in enumerate(sorted_nums):
            if num not in count_smaller:
                count_smaller[num] = i
        
        # Generate the result array based on the dictionary
        result = []
        for num in nums:
            result.append(count_smaller[num])
        
        return result

1374
class Solution:
    def generateTheString(self, n: int) -> str:
        if n % 2 == 1:
            return 'a' * n
        else:
            return 'a' * (n - 1) + 'b'

1379
class Solution:
    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:
        def dfs(node_original, node_cloned):
            if node_original is None:
                return None
            if node_original == target:
                return node_cloned
            left_result = dfs(node_original.left, node_cloned.left)
            if left_result:
                return left_result
            return dfs(node_original.right, node_cloned.right)
        
        return dfs(original, cloned)

1380
from typing import List

class Solution:
    def luckyNumbers (self, matrix: List[List[int]]) -> List[int]:
        # Initialize lists to store minimums of rows and maximums of columns
        min_rows = [min(row) for row in matrix]
        max_cols = [max(matrix[i][j] for i in range(len(matrix))) for j in range(len(matrix[0]))]
        
        # Find the intersection of minimum rows and maximum columns
        lucky_numbers = [matrix[i][j] for i in range(len(matrix)) for j in range(len(matrix[0])) 
                         if matrix[i][j] == min_rows[i] and matrix[i][j] == max_cols[j]]
        
        return lucky_numbers

1385
from typing import List

class Solution:
    def findTheDistanceValue(self, arr1: List[int], arr2: List[int], d: int) -> int:
        count = 0
        for x in arr1:
            valid = True
            for y in arr2:
                if abs(x - y) <= d:
                    valid = False
                    break
            if valid:
                count += 1
        return count

1389
class Solution:
    def createTargetArray(self, nums: List[int], index: List[int]) -> List[int]:
        target = []
        for num, idx in zip(nums, index):
            target.insert(idx, num)
        return target

1394
from typing import List

class Solution:
    def findLucky(self, arr: List[int]) -> int:
        frequency = {}
        
        # Count frequencies of each number in arr
        for num in arr:
            if num in frequency:
                frequency[num] += 1
            else:
                frequency[num] = 1
        
        # Initialize the maximum lucky number found
        max_lucky = -1
        
        # Find the maximum number where number equals its frequency
        for num, count in frequency.items():
            if num == count:
                max_lucky = max(max_lucky, num)
        
        return max_lucky
1399
class Solution:
    def countLargestGroup(self, n: int) -> int:
        # Helper function to calculate digit sum
        def digit_sum(num):
            return sum(int(digit) for digit in str(num))
        
        # Dictionary to store sum of digits -> count of numbers
        digit_sum_count = {}
        
        # Iterate over each number from 1 to n
        for num in range(1, n + 1):
            sum_digits = digit_sum(num)
            if sum_digits in digit_sum_count:
                digit_sum_count[sum_digits] += 1
            else:
                digit_sum_count[sum_digits] = 1
        
        # Find the largest sum of digits
        max_sum = max(digit_sum_count.values())
        
        # Count how many times the largest sum appears
        largest_group_count = sum(1 for count in digit_sum_count.values() if count == max_sum)
        
        return largest_group_count

1403
from typing import List

class Solution:
    def minSubsequence(self, nums: List[int]) -> List[int]:
        total_sum = sum(nums)
        nums.sort(reverse=True)
        subsequence = []
        subsequence_sum = 0
        
        for num in nums:
            subsequence.append(num)
            subsequence_sum += num
            if subsequence_sum > total_sum / 2:
                break
        
        return subsequence

1408
from typing import List

class Solution:
    def stringMatching(self, words: List[str]) -> List[str]:
        result = []
        
        for i in range(len(words)):
            word1 = words[i]
            for j in range(len(words)):
                word2 = words[j]
                if i != j and word1 in word2 and word1 not in result:
                    result.append(word1)
        
        return result

1413
from typing import List

class Solution:
    def minStartValue(self, nums: List[int]) -> int:
        min_start_value = 1
        current_sum = 0
        
        for num in nums:
            current_sum += num
            min_start_value = max(min_start_value, 1 - current_sum)
        
        return min_start_value

1417
class Solution:
  def reformat(self, s: str) -> str:
        digits = [ch for ch in s if ch.isdigit()]
        letters = [ch for ch in s if ch.isalpha()]
        
        if abs(len(digits) - len(letters)) > 1:
            return ""
        
        result = []
        if len(digits) >= len(letters):
            for i in range(len(letters)):
                result.append(digits[i])
                result.append(letters[i])
            if len(digits) > len(letters):
                result.append(digits[-1])
        else:
            for i in range(len(digits)):
                result.append(letters[i])
                result.append(digits[i])
            if len(letters) > len(digits):
                result.append(letters[-1])
        
        return ''.join(result)

1422
class Solution:
    def maxScore(self, s: str) -> int:
        count_zeros = 0
        count_ones = s.count('1')  # Count total '1's in the string
        max_score = 0
        
        # Traverse through the string, excluding the last character
        for i in range(len(s) - 1):
            if s[i] == '0':
                count_zeros += 1
            else:
                count_ones -= 1
            
            # Calculate current score
            current_score = count_zeros + count_ones
            max_score = max(max_score, current_score)
        
        return max_score

1431
1436
from typing import List

class Solution:
    def destCity(self, paths: List[List[str]]) -> str:
        start_cities = set()
        dest_cities = set()
        
        # Collect all start and destination cities in sets
        for path in paths:
            start_cities.add(path[0])
            dest_cities.add(path[1])
        
        # Find the destination city that is not in start_cities
        for city in dest_cities:
            if city not in start_cities:
                return city
        
        return ""

1446
class Solution:
    def maxPower(self, s: str) -> int:
        if not s:
            return 0
        
        max_power = 1
        current_power = 1
        
        for i in range(1, len(s)):
            if s[i] == s[i - 1]:
                current_power += 1
            else:
                max_power = max(max_power, current_power)
                current_power = 1
        
        # Update max_power after the loop in case the longest sequence ends at the end of the string
        max_power = max(max_power, current_power)
        
        return max_power
1507
class Solution:
    def reformatDate(self, date: str) -> str:
        months = {
            "Jan": "01", "Feb": "02", "Mar": "03", "Apr": "04",
            "May": "05", "Jun": "06", "Jul": "07", "Aug": "08",
            "Sep": "09", "Oct": "10", "Nov": "11", "Dec": "12"
        }
        
        day, month, year = date.split()
        day = day[:-2] if day[1].isdigit() else '0' + day[0]
        month = months[month]
        
        return f"{year}-{month}-{day}"

1550
from typing import List

class Solution:
    def threeConsecutiveOdds(self, arr: List[int]) -> bool:
        count = 0
        for num in arr:
            if num % 2 != 0:
                count += 1
                if count == 3:
                    return True
            else:
                count = 0
        return False
1768
1935

